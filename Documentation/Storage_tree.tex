
\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{latexsym}
\usepackage{float}
\usepackage{parskip}
\usepackage{amsfonts}
\usepackage{caption}
\usepackage{commath}
\usepackage{amssymb,amsmath}
\usepackage{graphicx}
\usepackage[backend=bibtex,style=numeric,sorting=none]{biblatex}
\usepackage[export]{adjustbox}
\usepackage{subcaption}
\usepackage[top=1in, bottom=1in,left=1in, right=1in]{geometry}
\usepackage{minted}
\usepackage{color}

\newcommand{\tc}{\textcolor{red}}
\newcommand{\bs}{\boldsymbol}

\newenvironment{alphafootnotes}
  {\par\edef\savedfootnotenumber{\number\value{footnote}}
   \renewcommand{\thefootnote}{\alph{footnote}}
   \setcounter{footnote}{0}}
  {\par\setcounter{footnote}{\savedfootnotenumber}}


\normalsize
\pagenumbering{arabic}

\usepackage[utf8]{inputenc}

\title{Documentation for Storage\_tree.py}
\author{Yili Yang}
\date{June 2017}

\begin{document}

\maketitle

\section{Introduction}
Storage\_tree.py is a file containing two class of storage tree for the DLW model.The storage trees are dictionary storing various info mation for each node within a tree object. For convenience, the class mainly provides a dict with key of period times (i.e. [0,15,45,85,100]) and item of information (i.e mitigation level on each node). \\
The main difference between storage tree object and tree object is that the storage tree don't have index for nodes and states, all the information in this kind of tree is specific and it merely for storage usage which means you can not find path or reachable nodes using this class.

\section{Python:Storage\_tree.py}
\subsection{Base Class}
 Base Class is an bstract storage class for the EZ-Climate model.
\subsubsection{Inputs and Outputs}
\textbf{Inputs}:
\begin{itemize}
\item \textbf{decision\_times}:(ndarray or list) array of years from start where decisions about mitigation levels are done
\end{itemize}
\textbf{Outputs}:\\
It doesn't have outputs since it's a abstract class.
\subsubsection{Attributes}
\begin{itemize}
\item \textbf{decision\_times}:(ndarray) array of years from start where decisions about mitigation levels are done.
\item \textbf{information\_times}:(ndarray) array of years where new information is given to the agent in the model.
\item \textbf{periods}: (ndarray) 	periods in the tree.
\item \textbf{tree}: (dict) dictionary where keys are `periods` and values are nodes in period. For big tree, there is an example,
\begin{minted}{python}
    >>> bst = BigStorageTree(5.0, [0, 15, 45, 85, 100])
    >>> bst.tree
    {0.0: array([ 0.]),
     5.0: array([ 0.,  0.]),
     10.0: array([ 0.,  0.]),
     15.0: array([ 0.,  0.]),
     20.0: array([ 0.,  0.,  0.,  0.]),
     25.0: array([ 0.,  0.,  0.,  0.]),
     30.0: array([ 0.,  0.,  0.,  0.]),
     35.0: array([ 0.,  0.,  0.,  0.]),
     40.0: array([ 0.,  0.,  0.,  0.]),
     45.0: array([ 0.,  0.,  0.,  0.]),
     50.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     55.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     60.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     65.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     70.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     75.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     80.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     85.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     90.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     95.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     100.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])}
\end{minted}
    It only split when hitting the "can make dicision time" (elements in the information\_times attr)\\
    While for small trees, periods will only be [0, 15, 45, 85, 100]
\end{itemize}

\subsubsection{methods}
The basic components of this class is a init with decision times. Also, it introduces a new concept: \textbf{information\_times}, which is an array of years where new information is given to the agent in the model. In the base model, the information time is the periods of tree excluding the final state since we get the full knowledge on the T-1 state.\\
Also, the class has a \_\_getitem\_\_ enableing using it as a dict ( the main usage I metioned) and a \_\_len\_\_ get its size easily.
\begin{minted}{python}
	def __init__(self, decision_times):
		self.decision_times = decision_times
		if isinstance(decision_times, list):
			self.decision_times = np.array(decision_times)
		self.information_times = self.decision_times[:-2] # exclude the final period which we will have the full infomation
		self.periods = None
		self.tree = None

	def __len__(self):
		return len(self.tree)

	def __getitem__(self, key):
		if isinstance(key, int) or isinstance(key, float):
			return self.tree.__getitem__(key).copy()
		else:
			raise TypeError('Index must be int, not {}'.format(type(key).__name__))
\end{minted}
\textbf{\_init\_tree}: The most important method is this method which gives the class a main dictionary to work with. It is a dictionary with key of periods and items of zero arrays with the right size. (binomial sense)
\begin{minted}{python}
	def _init_tree(self):
		self.tree = dict.fromkeys(self.periods)
		i = 0
		for key in self.periods:
			self.tree[key] = np.zeros(2**i)
			if key in self.information_times:
				i += 1
\end{minted}
some frequently used properties of the tree model including:
\begin{itemize}
  \item last period's array
  \item index of last period
  \item number of nodes in the tree
\end{itemize}

\begin{minted}{python}
	@property
	def last(self):
		"""ndarray: last period's array."""
		return self.tree[self.decision_times[-1]]

	@property
	def last_period(self):
		"""int: index of last period."""
		return self.decision_times[-1]

	@property
	def nodes(self):
		"""int: number of nodes in the tree."""
		n = 0
		for array in self.tree.values():
			n += len(array)
		return n
\end{minted}
Abstract method for latter usage.
\begin{minted}{python}
	@abstractmethod
	def get_next_period_array(self, period):
		"""Return the array of the next period from `periods`."""
		pass
\end{minted}
\textbf{set\_value} : set value for all the node with a period using the given value.
\begin{minted}{python}
	def set_value(self, period, values):
		"""If period is in periods, set the value of element to `values` (ndarray)."""
		if period not in self.periods:
			raise ValueError("Not a valid period")
		if isinstance(values, list):
			values = np.array(values)
		if self.tree[period].shape != values.shape:
			raise ValueError("shapes {} and {} not aligned".format(self.tree[period].shape, values.shape))
		self.tree[period] = values
\end{minted}
boolean check method to check whether a period is :
\begin{itemize}
  \item a decision time
  \item a decision time besides the last period
  \item a information time for fragility
\end{itemize}
\begin{minted}{python}
	def is_decision_period(self, time_period):
		"""Checks if time_period is a decision time for mitigation, where
		time_period is the number of years since start.

		Parameters
		----------
		time_period : int
			time since the start year of the model

		Returns
		-------
		bool
			True if time_period also is a decision time, else False

		"""
		return time_period in self.decision_times

	def is_real_decision_period(self, time_period):
		"""Checks if time_period is a decision time besides the last period, where
		time_period is the number of years since start.
		
		Parameters
		----------
		time_period : int
			time since the start year of the model

		Returns
		-------
		bool
			True if time_period also is a real decision time, else False

		"""
		return time_period in self.decision_times[:-1]

	def is_information_period(self, time_period):
		"""Checks if time_period is a information time for fragility, where
		time_period is the number of years since start.

		Parameters
		----------
		time_period : int
			time since the start year of the model

		Returns
		-------
		bool
			True if time_period also is an information time, else False

		"""
		return time_period in self.information_times
\end{minted}
\textbf{write\_tree}: A standard save method for storage trees. It save the tree's info in a row but never been use in the following code.
\begin{minted}{python}
	def write_tree(self, file_name, header, delimiter=";"):
		"""Save values in `tree` as a tree into file  `file_name` in the
		'data' directory in the current working directory. If there is no 'data'
		directory, one is created.

		Parameters
		----------
		file_name : str
			name of saved file
		header : str
			first row of file
		delimiter : str, optional
			delimiter in file

		"""
		from tools import find_path
		import csv
		
		real_times = self.decision_times[:-1]
		size = len(self.tree[real_times[-1]])
		output_lst = []
		prev_k = size

		for t in real_times:
			temp_lst = [""]*(size*2)
			k = int(size/len(self.tree[t]))
			temp_lst[k::prev_k] = self.tree[t].tolist()
			output_lst.append(temp_lst)
			prev_k = k

		write_lst = zip(*output_lst)
		d = find_path(file_name)
		with open(d, 'wb') as f:
			writer = csv.writer(f, delimiter=delimiter)
			writer.writerow([header])
			for row in write_lst:
				writer.writerow(row)
\end{minted}
\textbf{write\_columns}: A standard save method for storage trees. It save the tree's info in a csv with the following template.
\begin{center}
\begin{tabular}{ |c|c|c| }
 \hline
 Year  &  Node  & header  \\
 \hline
 start_year & 0 & value0 \\
 \hline
 ... & ... & ... \\
 \hline
\end{tabular}
\end{center}
Also, the next method \textbf{write\_columns\_existing} save the trees info in a modified format.
This kind of format is trivial and convenient to be used directed in csv.
\begin{center}
\begin{tabular}{ |c|c|c|c| }
 \hline
 Year  &  Node  & other\_header & header  \\
 \hline
 start_year & 0 & other\_value & value0 \\
 \hline
 ... & ... & ... & ... \\
 \hline
\end{tabular}
\end{center}
\begin{minted}{python}
	def write_columns(self, file_name, header, start_year=2015, delimiter=";"):
		"""Save values in `tree` as columns into file  `file_name` in the
		'data' directory in the current working directory. If there is no 'data'
		directory, one is created.
		
		Parameters
		----------
		file_name : str
			name of saved file
		header : str
			description of values in tree
		start_year : int, optional
			start year of analysis
		delimiter : str, optional
			delimiter in file

		"""
		from tools import write_columns_csv, file_exists
		if file_exists(file_name):
			self.write_columns_existing(file_name, header)
		else:
			real_times = self.decision_times[:-1]
			years = []
			nodes = []
			output_lst = []
			k = 0
			for t in real_times:
				for n in range(len(self.tree[t])):
					years.append(t+start_year)
					nodes.append(k)
					output_lst.append(self.tree[t][n])
					k += 1
			write_columns_csv(lst=[output_lst], file_name=file_name, header=["Year", "Node", header],
							  index=[years, nodes], delimiter=delimiter)

	def write_columns_existing(self, file_name, header, delimiter=";"):
		"""Save values in `tree` as columns into file  `file_name` in the
		'data' directory in the current working directory, when `file_name` already exists.
		If there is no 'data' directory, one is created.

		Parameters
		----------
		file_name : str
			name of saved file
		header : str
			description of values in tree
		start_year : int, optional
			start year of analysis
		delimiter : str, optional
			delimiter in file

		"""
		from tools import write_columns_to_existing
		output_lst = []
		for t in self.decision_times[:-1]:
			output_lst.extend(self.tree[t])
		write_columns_to_existing(lst=output_lst, file_name=file_name, header=header)
\end{minted}
\subsection{Small Storage Tree}
A storage tree class for the EZ-Climate model. No storage in nodes between
	periods in `decision\_times`.
\subsubsection{Inputs, Outputs and Attributes}
The Inputs, Output and Attributes are the same as the BaseStorageTree
\subsubsection{methods}
\textbf{get\_next\_period\_array}: return a array consists of the decisions in the next period. A example of this method:
\begin{minted}{python}
		>>> sst = SmallStorageTree([0, 15, 45, 85, 185, 285, 385])
		>>> sst.get_next_period_array(0)
		array([0., 0.])
		>>> sst.get\_next\_period\_array(15)
		array([ 0.,  0.,  0.,  0.])
\end{minted}
\begin{minted}{python}
	def get_next_period_array(self, period):
		"""Returns the array of the next decision period.

		Parameters
		----------
		period : int
			period

		Raises
		------
		IndexError
			If `period` is not in real decision times

		"""
		if self.is_real_decision_period(period):
			index = self.decision_times[np.where(self.decision_times==period)[0]+1][0]
			return self.tree[index].copy()
		raise IndexError("Given period is not in real decision times")
\end{minted}
\textbf{index\_below}: returns the key (a decision time) of the previous decision period. An example of this:
\begin{minted}{python}
		>>> sst = SmallStorageTree([0, 15, 45, 85, 185, 285, 385])
		>>> sst.index_below(15)
		0
		
	def index_below(self, period):
		"""Returns the key of the previous decision period.

		Parameters
		----------
		period : int
			period

		Raises
		------
		IndexError
			If `period` is not in decision times or first element in decision times

		"""
		if period in self.decision_times[1:]:
			period = self.decision_times[np.where(self.decision_times==period)[0]-1]
			return period[0]
		raise IndexError("Period not in decision times or first period")
\end{minted}
\subsection{Big Storage Tree}
A storage tree class for the EZ-Climate model. This tree store all the information on every possible interval period. An example of this is:
\begin{minted}{python}
    >>> bst = BigStorageTree(5.0, [0, 15, 45, 85, 100])
    >>> bst.tree
    {0.0: array([ 0.]),
     5.0: array([ 0.,  0.]),
     10.0: array([ 0.,  0.]),
     15.0: array([ 0.,  0.]),
     20.0: array([ 0.,  0.,  0.,  0.]),
     25.0: array([ 0.,  0.,  0.,  0.]),
     30.0: array([ 0.,  0.,  0.,  0.]),
     35.0: array([ 0.,  0.,  0.,  0.]),
     40.0: array([ 0.,  0.,  0.,  0.]),
     45.0: array([ 0.,  0.,  0.,  0.]),
     50.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     55.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     60.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     65.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     70.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     75.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     80.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     85.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     90.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     95.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
     100.0: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])}
\end{minted}
\subsubsection{Inputs and Outputs}
\begin{itemize}
  \item \textbf{subintervals\_len} : (float) periods in tree
  \item \textbf{decision\_times} : (ndarray or list)
		array of years from start where decisions about mitigation levels are done
\end{itemize}
\subsubsection{Attributes}
\begin{itemize}
\item \textbf{decision\_times}:(ndarray) array of years from start where decisions about mitigation levels are done.
\item \textbf{information\_times}:(ndarray) array of years where new information is given to the agent in the model.
\item \textbf{periods}: (ndarray) 	periods in the tree.
\item \textbf{tree}: (dict) dictionary where keys are `periods` and values are nodes in period.
\item \textbf{subintervals\_len} : (float) years between periods in tree.
\end{itemize}

\subsubsection{methods}
\textbf{first\_period\_intervals}: return the number of subintervals in the first period. For example:
\begin{minted}{python}
    >>> bst.first_period_intervals()
    3
\end{minted}
\begin{minted}{python}
	@property
	def first_period_intervals(self):
		"""ndarray: the number of subintervals in the first period."""
		return int((self.decision_times[1] - self.decision_times[0]) / self.subinterval_len)
\end{minted}
\textbf{get\_next\_period\_array}: same as the small storage tree
\begin{minted}{python}
	def get_next_period_array(self, period):
		"""Returns the array of the next period.

		Parameters
		----------
		period : int
			period

		Examples
		--------
		>>> bst = BigStorageTree(5.0, [0, 15, 45, 85, 185, 285, 385])
		>>>bst.get_next_period_array(0)
		array([0., 0.])
		>>> bst.get_next_period_array(10)
		array([ 0.,  0., 0., 0.])

		Raises
		------
		IndexError
			If `period` is not a valid period or too large

		"""
		if period + self.subinterval_len <= self.decision_times[-1]:
			return self.tree[period+self.subinterval_len].copy()
		raise IndexError("Period is not a valid period or too large")
\end{minted}
\textbf{between\_decision\_times}: Check which decision time the period is between and returns
		the index of the lower decision time. An example for this is:
\begin{minted}{python}
		>>> bst = BigStorageTree(5, [0, 15, 45, 85, 185, 285, 385])
		>>> bst.between_decision_times(5)
		0
		>>> bst.between_decision_times(15)
		1
\end{minted}
\begin{minted}{python}
	def between_decision_times(self, period):
		"""

		Parameters
		----------
		period : int
			period

		Returns
		-------
		int
			index

		"""
		if period == 0:
			return 0
		for i in range(len(self.information_times)):
			if self.decision_times[i] <= period and period < self.decision_times[i+1]:
				return i
		return i+1
\end{minted}
\textbf{decision\_interval}: Check which interval the period is between. An example for this:
\begin{minted}{python}
		>>> bst = BigStorageTree(5, [0, 15, 45, 85, 185, 285, 385])
		>>> bst.decision_interval(5)
		1
		>>> bst.between_decision_times(15)
		1
		>>> bst.between_decision_times(20)
		2
\end{minted}
\begin{minted}{python}
	def decision_interval(self, period):
		"""
		
		Parameters
		----------
		period : int
			period

		Returns
		-------
		int
			index

		"""
		if period == 0:
			return 0
		for i in range(1, len(self.decision_times)):
			if self.decision_times[i-1] < period and period <= self.decision_times[i]:
				return i
		return i
\end{minted}
\end{document}
