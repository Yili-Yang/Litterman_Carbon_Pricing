\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{latexsym}
\usepackage{float}
\usepackage{parskip}
\usepackage{amsfonts}
\usepackage{caption}
\usepackage{commath}
\usepackage{amssymb,amsmath}
\usepackage{graphicx}
\usepackage[backend=bibtex,style=numeric,sorting=none]{biblatex}
\usepackage[export]{adjustbox}
\usepackage{subcaption}
\usepackage[top=1in, bottom=1in,left=1in, right=1in]{geometry}
\usepackage{minted}
\usepackage{color}

\newcommand{\tc}{\textcolor{red}}
\newcommand{\bs}{\boldsymbol}

\newenvironment{alphafootnotes}
  {\par\edef\savedfootnotenumber{\number\value{footnote}}
   \renewcommand{\thefootnote}{\alph{footnote}}
   \setcounter{footnote}{0}}
  {\par\setcounter{footnote}{\savedfootnotenumber}}


\normalsize
\pagenumbering{arabic}

\usepackage[utf8]{inputenc}

\title{Documentation for Analysis.py}
\author{Yili Yang}
\date{June 2017}

\begin{document}

\maketitle

\section{Introduction}
This code file is used to do sensitivity analysis about the EZ-climate model.
\section{Methods}
\textbf{additional\_ghg\_emission}: additional ghg caused by emission is the mitigation level now times the ghg level change w.r.t the emission in this period.
\begin{minted}{python}
def additional_ghg_emission(m, utility):
	"""Calculate the emission added by every node.

	Parameters
	----------
	m : ndarray or list
		array of mitigation
	utility : `Utility` object
		object of utility class
	
	Returns
	-------
	ndarray
		additional emission in nodes
	
	"""
	additional_emission = np.zeros(len(m))
	cache = set()
	for node in range(utility.tree.num_final_states, len(m)): # the number of final states equal to the sum of previous states
		path = utility.tree.get_path(node)
		for i in range(len(path)):
			if path[i] not in cache:
				additional_emission[path[i]] = (1.0 - m[path[i]]) *  utility.damage.bau.emission_to_ghg[i]
				cache.add(path[i])
	return additional_emission
\end{minted}

\textbf{store\_trees}: save the values in BaseStorageTree to a csv file.
\begin{minted}{python}
def store_trees(prefix=None, start_year=2015, **kwargs):
	"""Saves values of `BaseStorageTree` objects. The file is saved into the 'data' directory
	in the current working directory. If there is no 'data' directory, one is created.

	Parameters
	----------
	prefix : str, optional
		prefix to be added to file_name
	start_year : int, optional
		start year of analysis
	**kwargs
		arbitrary keyword arguments of `BaseStorageTree` objects

	"""
	if prefix is None:
		prefix = ""
	for name, tree in kwargs.items():
		tree.write_columns(prefix + "trees", name, start_year)
\end{minted}


\textbf{delta\_consumption}: Calculate the changes in consumption and the mitigation cost component of consumption when increasing period 0 mitigation with `delta_m`.
returns a tuple contains:
\begin{itemize}
  \item storage tree of changes in consumption per delta m
  \item ndarray of costs in first periods
  \item new utility at the start point
\end{itemize}

\begin{minted}{python}
def delta_consumption(m, utility, cons_tree, cost_tree, delta_m):
	"""Calculate the changes in consumption and the mitigation cost component
	of consumption when increaseing period 0 mitigiation with `delta_m`.

	Parameters
	----------
	m : ndarray or list
		array of mitigation
	utility : `Utility` object
		object of utility class
	cons_tree : `BigStorageTree` object
		consumption storage tree of consumption values
		from optimal mitigation values
	cost_tree : `SmallStorageTree` object
		cost storage tree of cost values from optimal mitigation values
	delta_m : float
		value to increase period 0 mitigation by
	
	Returns
	-------
	tuple
		(storage tree of changes in consumption per delta m, ndarray of costs in first periods, new utility at the start point)

	"""
	m_copy = m.copy()
	m_copy[0] += delta_m

	new_utility_tree, new_cons_tree, new_cost_tree, new_ce_tree = utility.utility(m_copy, return_trees=True)

	for period in new_cons_tree.periods:
		new_cons_tree.tree[period] = (new_cons_tree.tree[period]-cons_tree.tree[period]) / delta_m

	first_period_intervals = new_cons_tree.first_period_intervals
	cost_array = np.zeros((first_period_intervals, 2))
	for i in range(first_period_intervals):
		potential_consumption = (1.0 + utility.cons_growth)**(new_cons_tree.subinterval_len * i)
		cost_array[i, 0] = potential_consumption * cost_tree[0]
		cost_array[i, 1] = (potential_consumption * new_cost_tree[0] - cost_array[i, 0]) / delta_m
	
	return new_cons_tree, cost_array, new_utility_tree[0]
\end{minted}



\textbf{constraint\_first\_period}:  Calculate the changes in consumption, the mitigation cost component of consumption,
	and new mitigation values when constraining the first period mitigation to `first\_node`.
\begin{minted}{python}
def constraint_first_period(utility, first_node, m_size):
	"""Calculate the changes in consumption, the mitigation cost component of consumption,
	and new mitigation values when constraining the first period mitigation to `first_node`.

	Parameters
	----------
	m : ndarray or list
		array of mitigation
	utility : `Utility` object
		object of utility class
	first_node : float
		value to constrain first period to
	
	Returns
	-------
	tuple
		(new mitigation array, storage tree of changes in consumption, ndarray of costs in first sub periods)

	"""
	#fix the first period
	fixed_values = np.array([first_node])
	fixed_indicies = np.array([0])
	ga_model = GeneticAlgorithm(pop_amount=150, num_generations=100, cx_prob=0.8, mut_prob=0.5, bound=1.5,
								num_feature=m_size, utility=utility, fixed_values=fixed_values,
								fixed_indicies=fixed_indicies, print_progress=True)

	gs_model = GradientSearch(var_nums=m_size, utility=utility, accuracy=1e-7,
							  iterations=250, fixed_values=fixed_values, fixed_indicies=fixed_indicies,
							  print_progress=True)
	#run opt again
	final_pop, fitness = ga_model.run()
	sort_pop = final_pop[np.argsort(fitness)][::-1]
	new_m, new_utility = gs_model.run(initial_point_list=sort_pop, topk=1)
	return new_m
\end{minted}



\textbf{find\_ir}: Find the price of a bond that creates equal utility at time 0 as adding `payment` to the value of
	consumption in the final period. The purpose of this function is to find the interest rate.
	embedded in the `EZUtility` model. The first variable here is the utility with the final payment and the second variable is the utility with the initial payment.\\
\textbf{find\_term\_structure}: Find the price of a bond that creates equal utility at time 0 as adding `payment` to the value of
	consumption just before the final period. The purpose of this function is to find the interest rate.
	embedded in the `EZUtility` model. The first variable here is the utility with fix payment just before the final period and the second variable is the utility with the initial payment. \\
\textbf{find\_bec}: Used to find a value for consumption that equalizes utility at time 0 in two different solutions. The first variable here is utility with one init consumption and the second variable is the
utility with another init consumption\\
\textbf{perpetuity\_yield}: Find the yield of a perpetuity starting at year `start\_date`. The first variable here is the final price and the second is $\frac{\frac{100}{(perp\_yield+100.)^{start\_date}} * (perp\_yield + 100)}{perp\_yield}$\\
All of the function above is finding a point on the axis where the first variable equals the second using brentq method from scipy package.
\begin{minted}{python}
def find_ir(m, utility, payment, a=0.0, b=1.0):
	"""Find the price of a bond that creates equal utility at time 0 as adding `payment` to the value of
	consumption in the final period. The purpose of this function is to find the interest rate
	embedded in the `EZUtility` model.

	Parameters
	----------
	m : ndarray or list
		array of mitigation
	utility : `Utility` object
		object of utility class
	payment : float
		value added to consumption in the final period
	a : float, optional
		initial guess
	b : float, optional
		initial guess - f(b) needs to give different sign than f(a)
	
	Returns
	-------
	tuple
		result of optimization

	Note
	----
	requires the 'scipy' package

	"""

	def min_func(price):
		utility_with_final_payment = utility.adjusted_utility(m, final_cons_eps=payment)
		first_period_eps = payment * price
		utility_with_initial_payment = utility.adjusted_utility(m, first_period_consadj=first_period_eps)
		return utility_with_final_payment - utility_with_initial_payment

	return brentq(min_func, a, b)

def find_term_structure(m, utility, payment, a=0.0, b=1.5):
	"""Find the price of a bond that creates equal utility at time 0 as adding `payment` to the value of
	consumption just before the final period. The purpose of this function is to find the interest rate
	embedded in the `EZUtility` model.

	Parameters
	----------
	m : ndarray or list
		array of mitigation
	utility : `Utility` object
		object of utility class
	payment : float
		value added to consumption in the final period
	a : float, optional
		initial guess
	b : float, optional
		initial guess - f(b) needs to give different sign than f(a)
	
	Returns
	-------
	tuple
		result of optimization

	Note
	----
	requires the 'scipy' package

	"""

	def min_func(price):
		period_cons_eps = np.zeros(int(utility.decision_times[-1]/utility.period_len) + 1)
		period_cons_eps[-2] = payment
		utility_with_payment = utility.adjusted_utility(m, period_cons_eps=period_cons_eps)
		first_period_eps = payment * price
		utility_with_initial_payment = utility.adjusted_utility(m, first_period_consadj=first_period_eps)
		return  utility_with_payment - utility_with_initial_payment

	return brentq(min_func, a, b)

def find_bec(m, utility, constraint_cost, a=-0.1, b=1.5):
	"""Used to find a value for consumption that equalizes utility at time 0 in two different solutions.

	Parameters
	----------
	m : ndarray or list
		array of mitigation
	utility : `Utility` object
		object of utility class
	constraint_cost : float
		utility cost of constraining period 0 to zero
	a : float, optional
		initial guess
	b : float, optional
		initial guess - f(b) needs to give different sign than f(a)
	
	Returns
	-------
	tuple
		result of optimization

	Note
	----
	requires the 'scipy' package

	"""

	def min_func(delta_con):
		base_utility = utility.utility(m)
		new_utility = utility.adjusted_utility(m, first_period_consadj=delta_con)
		print(base_utility, new_utility, constraint_cost)
		return new_utility - base_utility - constraint_cost

	return brentq(min_func, a, b)

def perpetuity_yield(price, start_date, a=0.1, b=10.0):
	"""Find the yield of a perpetuity starting at year `start_date`.

	Parameters
	----------
	price : float
		price of bond ending at `start_date`
	start_date : int
		start year of perpetuity
	a : float, optional
		initial guess
	b : float, optional
		initial guess - f(b) needs to give different sign than f(a)
	
	Returns
	-------
	tuple
		result of optimization

	Note
	----
	requires the 'scipy' package

	"""
	
	def min_func(perp_yield):
		return price - (100. / (perp_yield+100.))**start_date * (perp_yield + 100)/perp_yield

	return brentq(min_func, a, b)
\end{minted}

\subsection{Climate Output Class}
Calculate and save output from the EZ-Climate model
\subsubsection{Inputs and Outputs}
\textbf{Inputs}:
\begin{itemize}
  \item \textbf{utility} : (`Utility` object)
		object of utility class
\end{itemize}
\textbf{Outputs}:
Calculated values based on optimal mitigation. For every \textbf{node} the function calculates and saves:
\begin{itemize}
  \item average mitigation
  \item average emission
  \item GHG level
  \item SCC
\end{itemize}
For every **period** the function also calculates and saves:
\begin{itemize}
  \item expected SCC/price
  \item expected mitigation
  \item expected emission
\end{itemize}
\subsubsection{Attributes}
\begin{itemize}
  \item	\textbf{utility} : (`Utility` object)
		object of utility class
  \item \textbf{prices} : ndarray
		SCC prices
  \item 	\textbf{ave\_mitigations} : (ndarray)
		average mitigations
  \item 	\textbf{ave\_emissions} : (ndarray)
		average emissions
  \item 	\textbf{expected\_period\_price }: (ndarray)
		expected SCC for the period
  \item  	\textbf{expected\_period\_mitigation} : (ndarray)
		expected mitigation for the period
  \item 	\textbf{expected\_period\_emissions} : (ndarray)
		expected emission for the period
\end{itemize}

\begin{minted}{python}
def calculate_output(self, m):
	"""Calculated values based on optimal mitigation. For every **node** the function calculates and saves
		
		* average mitigation
		* average emission
		* GHG level
		* SCC

	as attributes.

	For every **period** the function also calculates and saves
		
		* expected SCC/price
		* expected mitigation
		* expected emission
	
	as attributes.

	Parameters
	----------
	m : ndarray or list
		array of mitigation

	"""

	bau = self.utility.damage.bau
	tree = self.utility.tree
	periods = tree.num_periods

	self.prices = np.zeros(len(m))
	self.ave_mitigations = np.zeros(len(m))
	self.ave_emissions = np.zeros(len(m))
	self.expected_period_price = np.zeros(periods)
	self.expected_period_mitigation = np.zeros(periods)
	self.expected_period_emissions = np.zeros(periods)
	additional_emissions = additional_ghg_emission(m, self.utility)
	self.ghg_levels = self.utility.damage.ghg_level(m)

	for period in range(0, periods):
		years = tree.decision_times[period]
		period_years = tree.decision_times[period+1] - tree.decision_times[period]
		nodes = tree.get_nodes_in_period(period)
		num_nodes_period = 1 + nodes[1] - nodes[0]
		period_lens = tree.decision_times[:period+1]
		
		for node in range(nodes[0], nodes[1]+1):
			path = np.array(tree.get_path(node, period))
			new_m = m[path]
			mean_mitigation = np.dot(new_m, period_lens) / years
			price = self.utility.cost.price(years, m[node], mean_mitigation)
			self.prices[node] = price
			self.ave_mitigations[node] = self.utility.damage.average_mitigation_node(m, node, period)
			self.ave_emissions[node] = additional_emissions[node] / (period_years*bau.emission_to_bau)
		
		probs = tree.get_probs_in_period(period)
		self.expected_period_price[period] = np.dot(self.prices[nodes[0]:nodes[1]+1], probs)
		self.expected_period_mitigation[period] = np.dot(self.ave_mitigations[nodes[0]:nodes[1]+1], probs)
		self.expected_period_emissions[period] = np.dot(self.ave_emissions[nodes[0]:nodes[1]+1], probs)

def save_output(self, m, prefix=None):
	"""Function to save calculated values in `calculate_output` in the file `prefix` + 'node_period_output'
	in the 'data' directory in the current working directory.

	The function also saves the values calculated in the utility function in the file
	`prefix` + 'tree' in the 'data' directory in the current working directory.

	If there is no 'data' directory, one is created.

	Parameters
	----------
	m : ndarray or list
		array of mitigation
	prefix : str, optional
		prefix to be added to file_name

	"""
	utility_tree, cons_tree, cost_tree, ce_tree = self.utility.utility(m, return_trees=True)
	
	if prefix is not None:
		prefix += "_"
	else:
		prefix = ""

	write_columns_csv([m, self.prices, self.ave_mitigations, self.ave_emissions, self.ghg_levels],
	                   prefix+"node_period_output", ["Node", "Mitigation", "Prices", "Average Mitigation",
	                   "Average Emission", "GHG Level"], [range(len(m))])

	append_to_existing([self.expected_period_price, self.expected_period_mitigation, self.expected_period_emissions],
						prefix+"node_period_output", header=["Period", "Expected Price", "Expected Mitigation",
						"Expected Emission"], index=[range(self.utility.tree.num_periods)], start_char='\n')

	store_trees(prefix=prefix, Utility=utility_tree, Consumption=cons_tree,
		        Cost=cost_tree, CertainEquivalence=ce_tree)
\end{minted}



\subsection{Risk Decomposition Class}
new risk decomposition method, need the new paper to document it.
\begin{minted}{python}

class RiskDecomposition(object):
	"""Calculate and save analysis of output from the EZ-Climate model.

	Parameters
	----------
	utility : `Utility` object
		object of utility class

	Attributes
	----------
	utility : `Utility` object
		object of utility class
	sdf_tree : `BaseStorageTree` object
		SDF for each node
	expected_damages : ndarray
		expected damages in each period
	risk_premium : ndarray
		risk premium in each period
	expected_sdf : ndarray
		expected SDF in each period
	cross_sdf_damages : ndarray
		cross term between the SDF and damages
	discounted_expected_damages : ndarray
		expected discounted damages for each period
	net_discount_damages : ndarray
		net discount damage, i.e. when cost is also accounted for
	cov_term : ndarray
		covariance between SDF and damages

	"""

	def __init__(self, utility):
		self.utility = utility
		self.sdf_tree = BigStorageTree(utility.period_len, utility.decision_times)
		self.sdf_tree.set_value(0, np.array([1.0]))

		n = len(self.sdf_tree)
		self.expected_damages = np.zeros(n)
		self.risk_premiums = np.zeros(n)
		self.expected_sdf = np.zeros(n)
		self.cross_sdf_damages = np.zeros(n)
		self.discounted_expected_damages = np.zeros(n)
		self.net_discount_damages = np.zeros(n)
		self.cov_term = np.zeros(n)

		self.expected_sdf[0] = 1.0


	def sensitivity_analysis(self, m):
		"""Calculate sensitivity analysis based on the optimal mitigation. For every sub-period, i.e. the
		periods given by the utility calculations, the function calculates and saves:
			
			* discount prices
			* net expected damages
			* expected damages
			* discounted expected damages
			* risk premium
			* cross SDF & damages
			* covariance between SDF and damages

		as attributes.

		Parameters
		----------
		m : ndarray or list
			array of mitigation
		utility : `Utility` object
			object of utility class
		prefix : str, optional
			prefix to be added to file_name

		"""

		utility_tree, cons_tree, cost_tree, ce_tree = self.utility.utility(m, return_trees=True)
		cost_sum = 0
		# Calculate the changes in consumption and the mitigation cost component of consumption when increaseing period 0 mitigiation with `delta_m`
		self.delta_cons_tree, self.delta_cost_array, delta_utility = delta_consumption(m, self.utility, cons_tree, cost_tree, 0.01)
		# Calculate the marginal utilities
		mu_0, mu_1, mu_2 = self.utility.marginal_utility(m, utility_tree, cons_tree, cost_tree, ce_tree)
		sub_len = self.sdf_tree.subinterval_len
		i = 1
		# for every period in sdf_tree (except the init point),
		for period in self.sdf_tree.periods[1:]:
			node_period = self.sdf_tree.decision_interval(period)
			period_probs = self.utility.tree.get_probs_in_period(node_period)
			expected_damage = np.dot(self.delta_cons_tree[period], period_probs)
			self.expected_damages[i] = expected_damage # calculate the expected damage (= sigma(cons_increased_per_delta * prob)), not neccessary the damage, more like excess utility
			
			if self.sdf_tree.is_information_period(period-self.sdf_tree.subinterval_len):
				total_probs = period_probs[::2] + period_probs[1::2]
				mu_temp = np.zeros(2*len(mu_1[period-sub_len]))
				mu_temp[::2] = mu_1[period-sub_len]
				mu_temp[1::2] = mu_2[period-sub_len]
				sdf = (np.repeat(total_probs, 2) / period_probs) * (mu_temp/np.repeat(mu_0[period-sub_len], 2))
				period_sdf = np.repeat(self.sdf_tree.tree[period-sub_len],2)*sdf
			else:
				sdf = mu_1[period-sub_len]/mu_0[period-sub_len]
				period_sdf = self.sdf_tree[period-sub_len]*sdf

			self.expected_sdf[i] = np.dot(period_sdf, period_probs)
			self.cross_sdf_damages[i] = np.dot(period_sdf, self.delta_cons_tree[period]*period_probs) # actual utility loss in a period
			self.cov_term[i] = self.cross_sdf_damages[i] - self.expected_sdf[i]*expected_damage # actual_utility_loss - expecte_price*expected_damage

			self.sdf_tree.set_value(period, period_sdf)

			if i < len(self.delta_cost_array):
				self.net_discount_damages[i] = -(expected_damage + self.delta_cost_array[i, 1]) * self.expected_sdf[i] / self.delta_cons_tree[0] # price / consumption
				cost_sum += -self.delta_cost_array[i, 1] * self.expected_sdf[i] / self.delta_cons_tree[0]
			else:
				self.net_discount_damages[i] = -expected_damage * self.expected_sdf[i] / self.delta_cons_tree[0]

			self.risk_premiums[i] = -self.cov_term[i]/self.delta_cons_tree[0]
			self.discounted_expected_damages[i] = -expected_damage * self.expected_sdf[i] / self.delta_cons_tree[0]
			i += 1

	def save_output(self, m, prefix=None):
		"""Save attributes calculated in `sensitivity_analysis` into the file prefix + `sensitivity_output`
		in the `data` directory in the current working directory.

		Furthermore, the perpetuity yield, the discount factor for the last period is calculated, and SCC,
		expected damage and risk premium for the first period is calculated and saved in into the file
		prefix + `tree` in the `data` directory in the current working directory. If there is no `data` directory,
		one is created.

		Parameters
		----------
		m : ndarray or list
			array of mitigation
		prefix : str, optional
			prefix to be added to file_name

		"""
		end_price = find_term_structure(m, self.utility, 0.01)
		perp_yield = perpetuity_yield(end_price, self.sdf_tree.periods[-2])

		damage_scale = self.utility.cost.price(0, m[0], 0) / (self.net_discount_damages.sum()+self.risk_premiums.sum())
		scaled_discounted_ed = self.net_discount_damages * damage_scale
		scaled_risk_premiums = self.risk_premiums * damage_scale

		if prefix is not None:
			prefix += "_"
		else:
			prefix = ""

		write_columns_csv([self.expected_sdf, self.net_discount_damages, self.expected_damages, self.risk_premiums,
			               self.cross_sdf_damages, self.discounted_expected_damages, self.cov_term,
			               scaled_discounted_ed, scaled_risk_premiums], prefix + "sensitivity_output",
						   ["Year", "Discount Prices", "Net Expected Damages", "Expected Damages", "Risk Premium",
						    "Cross SDF & Damages", "Discounted Expected Damages", "Cov Term", "Scaled Net Expected Damages",
						    "Scaled Risk Premiums"], [self.sdf_tree.periods.astype(int)+2015])

		append_to_existing([[end_price], [perp_yield], [scaled_discounted_ed.sum()], [scaled_risk_premiums.sum()],
			                [self.utility.cost.price(0, m[0], 0)]], prefix+"sensitivity_output",
			                header=["Zero Bound Price", "Perp Yield", "Expected Damages", "Risk Premium",
							"SCC"], start_char='\n')
		
		store_trees(prefix=prefix, SDF=self.sdf_tree, DeltaConsumption=self.delta_cons_tree)
\end{minted}
\subsection{Constraint Analysis Class}
\subsection{Output}
\begin{itemize}
     \item Constraint Cost (optimum cost - cost with constraint on first period)
     \item Delta Consumption ( value for consumption that equalizes utility at time 0 in two different solutions)
     \item Delta Consumption \$b (Delta Consumption * consumption per ton constant / emit level on init point
     \item Delta Emission Gton ( optimum emit level on the init point)
     \item Deadweight Cost (Delta Consumption * consumption per ton constant / optimum mitigation level on init point)
     \item Marginal Impact Utility (change of utility when add 0.01 on the init consumption)
     \item Marginal Benefit Emissions Reduction (change when change mitigation level on init point by 0.01 / change when change consumption level on init point by 0.01 * consumption per ton constant)
     \item Marginal Cost Emission Reduction (change on price when add constraint on the first period)
\end{itemize}
where consumption per ton constant is equal to $\frac{cons\_at\_0}{emit\_at\_0}$
\begin{minted}{python}
class ConstraintAnalysis(object):
	def __init__(self, run_name, utility, const_value, opt_m=None):
		self.run_name = run_name
		self.utility = utility
		self.cfp_m = constraint_first_period(utility, const_value, utility.tree.num_decision_nodes)
		self.opt_m = opt_m
		if self.opt_m is None:
			self.opt_m = self._get_optimal_m()

		self.con_cost = self._constraint_cost()
		self.delta_u = self._first_period_delta_udiff()

		self.delta_c = self._delta_consumption()
		self.delta_c_billions = self.delta_c * self.utility.cost.cons_per_ton \
								* self.utility.damage.bau.emit_level[0]
		self.delta_emission_gton = self.opt_m[0]*self.utility.damage.bau.emit_level[0]
		self.deadweight = self.delta_c*self.utility.cost.cons_per_ton / self.opt_m[0]

		# adjusted benefit when +0.01 to the mitigation level at time zero
		self.delta_u2 = self._first_period_delta_udiff2()
		self.marginal_benefit = (self.delta_u2 / self.delta_u) * self.utility.cost.cons_per_ton # cons_per_ton = cons_at_0 / emit_at_0
		self.marginal_cost = self.utility.cost.price(0, self.cfp_m[0], 0)

	def _get_optimal_m(self):
		try:
			header, index, data = import_csv(self.run_name+"_node_period_output")
		except:
			print("No such file for the optimal mitigation..")
		return data[:, 0]

	def _constraint_cost(self):
		opt_u = self.utility.utility(self.opt_m)
		cfp_u = self.utility.utility(self.cfp_m)
		return opt_u - cfp_u

	def _delta_consumption(self):
		return find_bec(self.cfp_m, self.utility, self.con_cost) # value for consumption that equalizes utility at time 0 in two different solutions

	def _first_period_delta_udiff(self):
		u_given_delta_con = self.utility.adjusted_utility(self.cfp_m, first_period_consadj=0.01)
		cfp_u = self.utility.utility(self.cfp_m)
		return u_given_delta_con - cfp_u

	def _first_period_delta_udiff2(self):
		m = self.cfp_m.copy()
		m[0] += 0.01 # adjusted with a fixed number
		u = self.utility.utility(m)
		cfp_u = self.utility.utility(self.cfp_m)
		return u - cfp_u
		
	def save_output(self, prefix=None):
		if prefix is not None:
			prefix += "_"
		else:
			prefix = ""

		write_columns_csv([self.con_cost, [self.delta_c], [self.delta_c_billions], [self.delta_emission_gton],
						   [self.deadweight], self.delta_u, self.marginal_benefit, [self.marginal_cost]],
						   prefix + self.run_name + "_constraint_output",
						  ["Constraint Cost", "Delta Consumption", "Delta Consumption \$b",
						   "Delta Emission Gton", "Deadweight Cost", "Marginal Impact Utility",
						   "Marginal Benefit Emissions Reduction", "Marginal Cost Emission Reduction"])
\end{minted}
\end{document}
